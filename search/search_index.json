{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Overview", "text": ""}, {"location": "#overview", "title": "Overview", "text": "A distributed midi controller. <p>The Crowd Controller devices can be used to give a crowd of people the ability to control a single midi device. The devices are connected to a central computer via Bluetooth. The central computer runs a Python client that communicates with the devices and the Digital Audio Workstation (DAW) using a virtual midi port.</p> <p>Each device consists of a rotary encoder, a button, and a series of WS2812 RGB LEDs. The rotary encoder is used to change the value of a midi parameter, the button can be mapped to trigger notes or midi control messages, and the LEDs can be used to give feedback to the user.</p> <pre><code>graph TD\n    subgraph Device\n        RENC[Rotary Encoder] --&gt; ESP32[ESP32]\n        BTN[Button] --&gt; ESP32\n        ESP32 --&gt; WS2812[WS2812] \n    end\n\n    subgraph Laptop\n        ESP32 -- Bluetooth(CTRL) --&gt; PC[Python Client]\n        PC[Python Client] -- Bluetooth(LED) --&gt; ESP32\n\n        PC -- MIDI --&gt; DAW[DAW]\n        LI[LED controller Client] -- ? --&gt; PC\n    end</code></pre>"}, {"location": "electronics/", "title": "Electronics", "text": ""}, {"location": "electronics/#electronics", "title": "Electronics", "text": ""}, {"location": "electronics/#bom", "title": "BOM", "text": "<ul> <li>ESP32 C3 Mini Dev Board</li> <li>EC11 Rotary Encoder</li> <li>Ws2812b Led ring 12 leds (Button)</li> <li>WS2812B Led ring 16 leds (Dial)</li> <li>2X CR123A Battery holder</li> <li>JST Connectors (1x2pin, 1x3pin and 1x4pin)</li> <li>Toggle switch</li> <li>2x100nF capacitor (SMD 0805)</li> <li>2x10uF capacitor (SMD 0805)</li> <li>1x diode (SMD 0805)</li> </ul> LED Ring Sizes <p>LED with an equal number of LED\u2019s don\u2019t necessarily have the same diameter. Ultimately these LED-Rings were used:</p> Button ring LEDs 8 inner diameter 18mm outer diameter 32mm Dial ring LEDs 16 inner diameter 54mm outer diameter 70mm"}, {"location": "electronics/#schematic", "title": "Schematic", "text": "Schematic Version 1"}, {"location": "electronics/#power", "title": "Power", "text": "<p>A diode is placed between the batteries and the <code>VCC</code> net in order to prevent current to flow back to the batteries when connected to the USB.</p>"}, {"location": "electronics/#led-rings", "title": "LED Rings", "text": "<p>The LED rings are now controlled by the ESP32 as one strip. The <code>DO</code> (Data Out) pin of the dial ring is connected to the <code>DI</code> (Data In) pin of the button ring. This will have less implications the timing in the firmware, as there is only one LED strip to manage.</p>"}, {"location": "electronics/#pin-numbers", "title": "Pin numbers", "text": "<p>The rotary encoder now uses pins 20 and 21.</p>"}, {"location": "electronics/#decoupling", "title": "Decoupling", "text": "<p>The ESP32 and the LED strip are now decoupled with a 100nF and a 10uF capacitor each to prevent voltage fluctuations.</p>"}, {"location": "electronics/#unused-pins", "title": "Unused pins", "text": "<p>Unused pins are now broken out for future prototyping.</p>"}, {"location": "electronics/#pcb", "title": "PCB", "text": "Top Bottom"}, {"location": "electronics/#connectors", "title": "Connectors", "text": "<p>JST connectors are used instead of bare pins.</p>"}, {"location": "electronics/#esp32-placement", "title": "ESP32 placement", "text": "<p>The ESP32 is now placed above a bare patch so there is less ground plane interference. To keep it less close to the metal of the rotary encoder, the ESP32 is now placed more to the side.</p>"}, {"location": "electronics/#switch", "title": "Switch", "text": "<p>Instead of bare pins, the battery power is now switched by a small switch at a 90 degree angle so the switch can be operated through a small hole at the side of the enclosure.</p>"}, {"location": "electronics/#prototype", "title": "Prototype", "text": "<ul> <li>Due to an error in the ESP32 part chosen for the schematic, <code>pin20</code> and pin21<code>where inadvertently chosen for the rotary encoder. These pins turned out to be</code>RX<code>and</code>TX` which are used for the serial port. Luckily pins 4 and 5 were broken out and situated very close to the rotary encoder on the PCB so this could easily be fixed in the prototype.</li> <li>Freshly charged Cr123 cells have a higher voltage than nominal so the total voltage of the power supply was &gt;8v in some cases. This is too high for both the ESP32 and the WS2812. This was fixed by:<ul> <li>Connecting the cells in parallel. Now the total voltage is nominally 3.7v which is a little too low but workable.</li> <li>Omitting the diode because the voltage drop of the diode would  get the voltage even lower.</li> </ul> </li> <li>The pin-headers weren\u2019t situated conveniently enough for the enclosure. The pin header for the button-ledring should me moved closer to the button.</li> <li>The ESP32 might as well be on the top of the board as it does not take to much space and sometimes it needs to be reset after the PCB has been built into the enclosure.</li> </ul>"}, {"location": "electronics/#improvements", "title": "Improvements", "text": ""}, {"location": "electronics/#high-priority", "title": "High priority", "text": "<ul> <li> Place ESP32 on top</li> <li> Put power cells in parallel or place a voltage regulator between cells and <code>VCC</code></li> <li> Use <code>pin4</code> and <code>pin5</code> for the rotary encoder.</li> <li> Break out <code>pin20</code> and <code>pin21</code> as <code>RXD</code> and <code>TXD</code></li> </ul>"}, {"location": "electronics/#low-priority", "title": "Low priority", "text": "<ul> <li> Battery charging using the XIAO ESP32 instead of the ESP32-Supermini boards</li> </ul> Previous versions Version 0Version 1"}, {"location": "electronics/#schematic_1", "title": "Schematic", "text": "Schematic"}, {"location": "electronics/#power_1", "title": "Power", "text": "<p>Two 3.7v batteries are serially connected to yield a maximum of 7.4v. The voltage regulator on the ESP32C3-Mini board will turn it into 3.3v for the ESP32. The WS2812 will hopefully be able to operate at a higher voltage.</p>"}, {"location": "electronics/#led-rings_1", "title": "LED Rings", "text": "<p>The two LED rings will each have a separate pin from the microcontroller.</p>"}, {"location": "electronics/#pcb_1", "title": "PCB", "text": "Bottom Top"}, {"location": "electronics/#connectors_1", "title": "Connectors", "text": "<p>The LED rings and the button will be connected using standard dupont cables. All connectors are situated at the bottom of the board.</p>"}, {"location": "electronics/#esp32-placement_1", "title": "ESP32 placement", "text": "<p>The ESP32 will be placed with the USB connector pointing upwards.</p>"}, {"location": "electronics/#switch_1", "title": "Switch", "text": "<p>The battery power can be turned on or off by shorting two pins.</p>"}, {"location": "electronics/#prototype_1", "title": "Prototype", "text": "<p>Reflecting on the prototype:</p> <ul> <li>The Bluetooth antenna of the ESP32 board was right above the ground plane which greatly diminished the bluetooth range.</li> <li>Unused pins weren\u2019t broken out so it was hard to add new features for prototyping.</li> <li>Bare connectors tend to get loose. Better use JST connectors instead.</li> <li>Using a jumper to switch on the device can\u2019t work if the device is inside an enclosure.</li> <li>Two separate WS2812 strips might make it harder to manage timing in software</li> </ul>"}, {"location": "enclosure/", "title": "Enclosure", "text": ""}, {"location": "enclosure/#enclosure", "title": "Enclosure", "text": "<p>A Crowd Controller device is meant to be held with one hand and operated by another. Therefore the device is shaped like a \u201cdroplet\u201d by connecting two circles with a curved line. The top circle contains the rotary encoder and the bottom circle contains the button. The LEDs are placed in a ring around both circles.</p> Exploded view of the Crowd Controller enclosure <p>Previous versions</p> Rhino3d PrevisualisationOpenscad parametric design Crowd Controller enclosure"}, {"location": "enclosure/#parametric-design", "title": "Parametric design", "text": "<p>Openscad is used to create a parametric design. To create the curved droplet shape, the following parameters are used:</p> <ul> <li>\\(r_1\\): The radius of the circle 1</li> <li>\\(r_2\\): The radius of the circle 2</li> <li>\\(r_3\\): The radius of the upper curve</li> <li>\\((x_1, y_1)\\): The center of circle 1</li> <li>\\((x_2, y_2)\\): The center of circle 2</li> </ul> <p>If these parameters are given, there are only two possible locations for the center of a third circle, \\((x_3, y_3)\\) that describes the curve that tangentially connects the two circles. </p> Finding the center of the third circle for the concave curve <p>By recognizing that the distance of the center of the third circle must be the sum of \\(r_1\\) and \\(r_3\\) as well as the sum of \\(r_2\\) and \\(r_3\\), the center of the third circle can be found by finding the intersection of two circles:</p> <ul> <li>Circle 1: </li> <li>position: \\((x_1, y_1)\\)</li> <li>\\(r: (r_1 + r_3)\\)</li> <li>Circle 2: </li> <li>position: \\((x_1, y_1)\\)</li> <li>\\(r: (r_2 - r_3)\\)</li> </ul> <p>To find the convex curve that connects the two circles, instead of adding the radii, the radii are subtracted:</p> <ul> <li>Circle 1: </li> <li>position: \\((x_1, y_1)\\)</li> <li>\\(r: (r_3 - r_1)\\)</li> <li>Circle 2: </li> <li>position: \\((x_2, y_2)\\)</li> <li>\\(r: (r_3 - r_2)\\)</li> </ul> Finding the convex curve"}, {"location": "installation/", "title": "Installation", "text": ""}, {"location": "installation/#installation", "title": "Installation", "text": ""}, {"location": "installation/#create-a-virtual-midi-device", "title": "Create a virtual midi device", "text": ""}, {"location": "installation/#macos", "title": "MacOS", "text": "<p>To create a virtual midi device on MacOS you can use the <code>IAC Driver</code>. To enable it, open the <code>Audio MIDI Setup</code> application and click on <code>Window</code> -&gt; <code>Show MIDI Studio</code>. Then double-click on the <code>IAC Driver</code>.</p> <ul> <li>check the <code>Device is online</code> checkbox.</li> <li>name the device <code>Crowd Controller</code>.</li> <li>click on the <code>+</code> button to add a new port and name it <code>Crowd Controller</code>.</li> </ul> MacOS MIDI setup"}, {"location": "installation/#windows", "title": "Windows", "text": "<p>To create a virtual midi device on Windows you can use the <code>loopMIDI</code> application. Download and install the application from Tobias Erichsen. Open the application and click on the <code>+</code> button to add a new port and name it <code>Crowd Controller</code>.</p> <p>Windows</p> <p>The <code>loopMIDI</code> application was not tested.</p>"}, {"location": "installation/#python-client", "title": "Python client", "text": "<p>To use the python library you need to install some libraries, preferably in a virtual environment. <code>cd</code> into the <code>crowd-controller/python-client</code> directory:</p> <pre><code>cd python-client\n</code></pre> <p>and run the following commands:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\n</code></pre> <p>Then you can run the client with:</p> <pre><code>python3 crowd-control-client.py\n</code></pre> <p>Testing the midi device</p> <p>You can test the midi-device in your DAW by running:</p> <pre><code>python3 mido-test.py\n</code></pre> <p>from the <code>python-client</code> directory. Some VCV Rack patches are included in the <code>vcv</code> directory to test the midi device but you can use any DAW.</p>"}, {"location": "installation/#esp32c3", "title": "ESP32C3", "text": "<p>To program the ESP32C3 you need to install the Arduino IDE and the ESP32 board support. Follow the instructions on the Espressif website to install the boards.</p>"}, {"location": "installation/#libraries", "title": "Libraries", "text": "<p>The following libraries are used in the ESP32 code:</p> <ul> <li>NeoPixel</li> <li>rotary-encoder</li> </ul>"}, {"location": "software/", "title": "Software", "text": ""}, {"location": "software/#software", "title": "Software", "text": "<p>A single crowd controller device consists of:</p> <ul> <li>a rotary encoder</li> <li>a button</li> <li>a series of WS2812 LEDs</li> <li>an ESP32 microcontroller</li> </ul>"}, {"location": "software/#rotary-encoder", "title": "Rotary encoder", "text": "Rotary encoder connections <ul> <li>No pull-up resistors are needed because the ESP32 has internal pull-up resistors.</li> </ul> <p>Read the encoder by hand:</p> <pre><code>void IRAM_ATTR updateRotary() {\n  int MSB = digitalRead(ROTARY_PIN_A);\n  int LSB = digitalRead(ROTARY_PIN_B);\n\n  int encoded = (MSB &lt;&lt; 1) | LSB;\n  int sum = (lastEncoded &lt;&lt; 2) | encoded;\n\n  if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011)\n    rotaryPosition++;\n  if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000)\n    rotaryPosition--;\n\n  lastEncoded = encoded;\n}\n</code></pre> <p>attached to the interrupt in the setup function:</p> <pre><code>pinMode(ROTARY_PIN_A, INPUT_PULLUP);\npinMode(ROTARY_PIN_B, INPUT_PULLUP);\n\n// Attach interrupts for rotary encoder\nattachInterrupt(digitalPinToInterrupt(ROTARY_PIN_A), updateRotary, CHANGE);\nattachInterrupt(digitalPinToInterrupt(ROTARY_PIN_B), updateRotary, CHANGE);\n</code></pre> <p>or use a library.</p>"}, {"location": "software/#bluetooth-communication", "title": "Bluetooth communication", "text": ""}, {"location": "software/#-python-library-bleak", "title": "- Python library bleak", "text": ""}, {"location": "software/#services-and-characteristics", "title": "Services and characteristics", "text": "<p>The ESP32 is set up as a BLE server with one service and three characteristics:</p> <pre><code>SERVICE_UUID = \"3796c365-5633-4744-bc65-cac7812ef6da\"\nBUTTON_CHARACTERISTIC_UUID = \"640033f1-08e8-429c-bd45-49ed4a60114e\"\nROTARY_CHARACTERISTIC_UUID = \"2a9ceeec-2d26-4520-bffe-8b13f00d4044\"\nWS2813_CHARACTERISTIC_UUID = \"dcfd575f-b5d4-42c2-bf57-c5141fe2eaa9\"\n</code></pre> <p>Service vs characteristic</p> <p>A service is a collection of characteristics. A characteristic is a value that can be read, written, or notified.</p> <p>Notifications did not work</p> <p>When using the <code>bleak</code> library, notifications did not work. The ESP32 would send the notification, but the Python client would not receive it. The error received was:</p> <pre><code>bleak.exc.BleakError: Notification was not acknowledged.\n</code></pre> <p>and later:</p> <pre><code>bleak.exc.BleakError: Failed to update the notification status for characteristic 41: Error Domain=CBATTErrorDomain Code=10 \"The attribute could not be found.\" UserInfo={NSLocalizedDescription=The attribute could not be found.}\n</code></pre> <p>A workaround was to poll the ESP32 for the value of the characteristic in an infinite, asynchronous loop.</p>"}]}